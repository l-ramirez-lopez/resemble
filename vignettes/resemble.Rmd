---
title: "Modelling complex spectral data with the resemble package"
author: 
 - name: Leonardo Ramirez-Lopez, Alexandre M.J.-C. Wadoux, Raphael Viscarra-Rossel, ???, ???, ..., ???
   email: ramirez.lopez.leo@gmail.com
date: "`r Sys.Date()`"
bibliography: ["one.bib"]
biblio-style: "apalike"
link-citations: true
output: knitr:::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Bulding highly accurate local models with the resemble package}
---

```{r setup, include = FALSE}
library(formatR)
knitr::opts_chunk$set(
  collapse = TRUE
)
```

<em><p align="right"> Think Globally, Fit Locally [@saul2003think] </p></em>


Modelling using spectral data has garnered wide interest in the last two decades. 
Spectroscopy is the study of the spectral response of a matrix (e.g. soil, 
plant material, seeds, etc.) when it interacts with electromagnetic radiation. 
This spectral response directly or indirectly relates to a wide range of 
compositional characteristics (chemical, physical or biological) of the matrix. 
Therefore, it is possible to develop empirical models that can accurately 
quantify properties of different matrices. In this respect, quantitative 
spectroscopy techniques are usually fast, non-destructive and cost-efficient in 
comparison to conventional laboratory methods used in the analyses of these 
matrices.  This has resulted in the development of comprehensive 
spectral databases for several agricultural products comprising large amounts 
of observations. The size of such databases increases *de facto* their 
complexity. To analyse large and complex spectral data, one must then resort 
numerical and statistical tools such as dimensionality reduction, and local 
spectroscopic modelling based on spectral similarity concepts.    

The aim of the `resemble` package is to provide tools to efficiently and 
accurately extract quantitative information from  large and complex spectral 
databases. The package contains functions for dimensionality reduction, 
spectral dissimilarity measurements, nearest neighbour search, and local modeling. 
The core functionality of the package include: 

* spectral dimension reduction
* the computation of similarity measures
* evaluation of dissimilarity matrices
* spectral neighbour search
* fitting local spectroscopic models
* plotting results of modelling

__Example dataset__
The example of this vignette uses external spectroscopic data. The spectral data 
are scans of soil samples recorded in the the visible and near-infrared (vis-NIR) 
range of the electromagnetic spectrum.
[here data description]

Load the necessary packages and data. [to be improve - maybe best separate 
package loading and data description]
```{r libraries, tidy = TRUE, message = FALSE}
library(resemble)
library(tidyr)
library(prospectr)
```

The data can be loaded into R using the following code. 
```{r, tidy = TRUE, message = FALSE}
data(NIRsoil)
# NIRsoil is a data.frame with 825 obs and 5 variables: 
# Nt (Total Nitrogen), Ciso (Carbon), CEC (Cation Exchange Capacity), 
# train (vector of 0,1 indicating training (1) and validation (0) samples),
# spc (spectral matrix)
str(NIRsoil)
```


Preprocess the data and split into calibration and validation...
```{r NIRsoil, tidy = TRUE, message = FALSE}
NIRsoil <- NIRsoil[NIRsoil$CEC %>% complete.cases(),]
wavs <- as.numeric(colnames(NIRsoil$spc))

NIRsoil$spc_p <- NIRsoil$spc %>% 
  standardNormalVariate() %>% 
  resample(wavs, seq(min(wavs), max(wavs), by = 11)) %>% 
  savitzkyGolay(p = 1, w = 5, m = 1)

train_x <- NIRsoil$spc_p[as.logical(NIRsoil$train), ]
train_y <- NIRsoil$CEC[as.logical(NIRsoil$train)]

test_x <- NIRsoil$spc_p[!as.logical(NIRsoil$train), ]
test_y <- NIRsoil$CEC[!as.logical(NIRsoil$train)]
```

## Dimension reduction


### Principal components

```{r}
# principal component analysis using 5 components
pc5_spectra <- ortho_projection(Xr = train_x, 
                             pc_selection = list("manual", 5), 
                             method = 'pca')

# display the information contained in the pcspectraRs object
print(pc5_spectra)
```
```{r}
plot(pc5_spectra)
```

### Projection to latent structures - Partial least squares

```{r}
# A partial least squares projection using the "opc" method
# for the selection of the optimal number of components
pls_projected <- ortho_projection(
  Xr = train_x , Xu = test_x, Yr = train_y, method = "pls",
  pc_selection = list("opc", 20)
)
pls_projected
plot(pls_projected)
```


```{r}
# A partial least squares projection using the "cumvar" method
# for the selection of the optimal number of components
pls_projected_2 <- ortho_projection(
  Xr = train_x , Xu = test_x, Yr = train_y,
  method = "pls",
  pc_selection = list("cumvar", 0.9)
)

pls_projected_2
plot(pls_projected_2)

```

### Optimal selection of the number of components when side information is available
[here a demonstration of why opc is much better than any other method of components selection]
```{r}
# principal components projection using the "opc" method
# for the selection of the optimal number of components

# perform the PCA
pc_opc_spectra <- ortho_projection(Xr = train_x, Xu = test_x, Yr = train_y,
                                method = "pca",
                                pc_selection = list("opc", value = 20))

# display the information contained in the pcspectraRs object
print(pc_opc_spectra)
```

```{r}
plot(pc_opc_spectra)
```

## Dissimilarity measures


### Correlation
```{r}
# compute correlation similarity with the resemble package
cd2 <- cor_diss(Xr = train_x, 
               Xu = train_x, 
               center = FALSE, scale = FALSE)

# check that the two methods have similar results 
round(x = cd2[1:3,1:3], digits = 5)
```

Alternatively, the correlation similarity can be computed using a moving window. In this case, the correlation similarity is computed by averaging the moving window correlation measures. It can be computationally demanding for large datasets. We start by defining a window size. 
```{r}
# the moving window value must be an odd number
w4cd <- 51 
```
Now we can use it in the `corDiss` function in `resemble`. 
```{r}
# compute the correlation similarity with a moving window
mwcd <- cor_diss(Xr = train_x, 
                Xu = train_x, 
                ws = w4cd,
                center = FALSE, scale = FALSE)

# check the first three correlation similarity values
mwcd[1:3,1:3]
```


### Euclidean distance

```{r, message=FALSE, warning=FALSE}
# compute Euclidean distance between spectra
EucD <- f_diss(Xr = train_x, 
              Xu = train_x, 
              diss_method = 'euclid', 
              center = TRUE, scale = TRUE)
```
We can then display the pairwise distance between the first three spectra of the dataset. 
```{r}
# print the pairwise distance between the three first spectra
EucD[1:3,1:3]
```

### Mahalanobis distance

```{r}
# specify the maximum amount of variance explained the one want to have retained
maxexplvar <- 0.99
```
Now we can compute the principal components of the absorbance spectra. 
```{r}
# compute the principal components
pcspectraA <- pc_projection(Xr = train_x, 
                          pc_selection = list('cumvar', maxexplvar),
                          method = 'pca',
                          center = TRUE, scale = FALSE)

# obtain the names of the sub-objects in the PC object created
names(pcspectraA)
```

The Mahalanobis distance between spectra can be computed by the `fDiss` function, using the PC scores as input.  
```{r}
# compute the Mahalanobis distance between spectra scores
mahD <- f_diss(Xr = pcspectraA$scores, 
              Xu = pcspectraA$scores, 
              diss_method = 'mahalanobis', 
              center = FALSE, scale = FALSE)
```
We can then display the pairwise distance between the first three scores of the absorbance spectra. 
```{r}
# print pairwise distance between the three first spectra
mahD[1:3,1:3]
```

### Spectral angle mapper

```{r}
# compute the pairwise SAM similarity 
samD <- f_diss(Xr = train_x, 
              Xu = train_x, 
              diss_method = 'cosine', 
              center = FALSE, scale = FALSE)

# show the first three similarity values
samD[1:3,1:3]
```

### Spectral information divergence

```{r}
# compute the pairwise SID similarity 
sidD <- sid(Xr = train_x, 
            Xu = train_x, 
            mode = 'density', 
            center = FALSE, scale = TRUE)

# show the first three similarity values
sidD$sid[1:3,1:3]
```

## Evaluating (dis-)similarity measures

[AW: I have a nice example]

## Neighbour search 

Neighbour search is used when having a dataset, it is necessary to identify/select 
its most spectrally similar observations from another dataset. This kind of subset 
selection can bee very useful when dealing with very large spectral 
datasets. ......

## Memory-based learning (MBL)

MBL has proven to be a method to derive highly accurate predictions from large 
spectral libraries ([@ramirez2013spectrum])...


```{r sblnorpint,  eval = TRUE, results='hide'}
# Use MBL as in Ramirez-Lopez et al. (2013)
sbl <- mbl(
  Xr = train_x, Yr = train_y, Xu = test_x,
  k = seq(50, 130, by = 20),
  method = local_fit_gpr(),
  control = mbl_control(validation_type = "NNv")
)
```

the resulting object can be plotted
```{r sblprintresult2,  eval = TRUE, include = TRUE, fig.cap = "Effect of first derivative and second derivative", fig.height = 6, fig.width = 10, tidy = TRUE, dpi = 50, out.height = "60%", out.width = "100%"}
plot(sbl)
```

### `mbl()` in parallel

Explain briefly how to do it and how it is. Mention that openMP is also used in 
cpp code

## RS-LOCAL

The RS-LOCAL algorithm was recently introduces by [@lobsey2017rs]...

### `rslocal()` in parallel

Explain briefly how to do it and how it is implemented



## References

