% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/funlib.R
\name{.get_all_fits}
\alias{.get_all_fits}
\title{Internal: Fit weighted local PLS models for all reference samples}
\usage{
.get_all_fits(
  ..k..,
  Xr,
  Yr,
  k,
  min_component,
  max_component,
  emgrid,
  scale,
  maxiter,
  tol,
  pc_selection,
  kidxmat,
  kidxgrop,
  dissimilarity_mat = NULL,
  pb,
  chunk_size,
  ...
)
}
\arguments{
\item{..k..}{Index (integer) indicating the number of neighbors to use
from vector \code{k}.}

\item{Xr}{A matrix or data.frame of predictor variables for the reference
data (rows = observations, columns = variables).}

\item{Yr}{A numeric vector of response values corresponding to \code{Xr}.}

\item{k}{A vector indicating the number of nearest neighbors to test for
each reference observation.}

\item{min_component}{Minimum number of components to use in PLS regression.}

\item{max_component}{Maximum number of components to use in PLS regression.}

\item{emgrid}{A matrix or grid of external evaluation weights.}

\item{scale}{Logical; if TRUE, scale predictors before regression.}

\item{maxiter}{Maximum number of iterations for the PLS algorithm.}

\item{tol}{Convergence tolerance for the PLS algorithm.}

\item{pc_selection}{A list specifying the principal component selection
method. Must contain:
\itemize{
\item{\code{method}:}{Character string; one of \code{"opc"},
\code{"cumvar"}, \code{"var"}, or \code{"manual"}.}
\item{\code{value}:}{Numeric; threshold or fixed number of components,
depending on the method.}
}
For example, \code{list(method = "opc", value = 40)}.}

\item{kidxmat}{Matrix of neighbor indices for each observation (columns =
samples, rows = neighbors).}

\item{kidxgrop}{Logical matrix indicating which neighbors belong to the
same group as the target and should be excluded.}

\item{dissimilarity_mat}{Optional matrix of dissimilarities between
reference observations, used to enhance feature input for PLS.}

\item{pb}{A progress bar object (e.g., from \code{txtProgressBar()}).}

\item{...}{Further arguments (currently unused).}
}
\value{
A matrix of predicted values (columns = observations in \code{Xr},
rows = emgrid dimensions).
}
\description{
Computes predictions from weighted local PLS models for each observation in
the reference set \code{Xr}, based on its nearest neighbors and optionally using
a dissimilarity matrix as extra predictive information.
}
\details{
#' @title Quantile Stats of Neighbor Responses
#' @description
#' Computes quantiles of the response values among the filtered
#' nearest neighbors for a specific sample.
#'
#' @param ..i.. Index of the sample being analyzed.
#' @param kidxmat Matrix of nearest neighbor indices (rows = neighbors).
#' @param kidxgrop Matrix mask to filter out same-group neighbors (TRUE = keep).
#' @param Yr Numeric response vector or 1-col matrix.
#' @param k Vector of neighbor counts for each sample.
#'
#' @return
#' A matrix of quantiles (0\%, 5\%, 25\%, 50\%, 75\%, 95\%, 100\%) of the
#' response values among the valid nearest neighbors.
#'
#' @details
#' For the i-th sample, this function selects the top-k neighbors for
#' each sample, filters using the group mask, and computes quantile
#' statistics from their corresponding response values in \code{Yr}.
#' @author Leonardo Ramirez-Lopez
#' @keywords internal
i_nn_stats <- function(..i.., kidxmat, kidxgrop, Yr, k) {
ik <- k\link{..i..}

jstats <- sapply(
1:ncol(kidxmat),
FUN = function(..j.., kidxmat, kidxgrop, Yr, ik){
inn <- kidxmat\link{1:ik,..j..}
inn <- inn[kidxgrop\link{1:ik,..j..}]
quantile(Yr\link{inn,}, c(0, 0.05, 0.25, 0.5, 0.75, 0.95, 1.00))
#sd(Yr\link{inn,})
},
kidxgrop = kidxgrop,
kidxmat = kidxmat,
Yr = Yr,
ik = ik
)
t(jstats)
}

For each reference observation in \code{Xr}, the function builds a local
training subset using the \code{ith_subsets_by_group()} function, fits a local
weighted PLS model via \code{ith_local_fit()}, and produces predictions based on
the evaluation grid (\code{emgrid}). Dissimilarity values can be optionally used
to augment predictive inputs. Parallel computation is handled via
\code{foreach} + \verb{\%dopar\%}.
}
\author{
Leonardo Ramirez-Lopez
}
\keyword{internal}
